# Vimm: Visual Interface for Materials Manipulation
#
# Copyright 2010 Caltech.  Copyright 2005 Sandia Corporation.  Under the terms of Contract
# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government
# retains certain rights in this sofware.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  
# USA


#!/usr/bin/env python
# generated by wxGlade 0.3.2 on Thu May 20 13:09:08 2004

import wx

from vimm.NumWrap import zeros
from vimm.Utilities import bbox_atoms, entry_int, entry_float
from vimm.MarchingCubes import contour

class OrbitalViewer(wx.Frame):
    def __init__(self, parent, id, title='Orbital Viewer',**kwds):
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, parent, id, title, **kwds)

        self.parent = parent
        self.geo = self.parent.material.geo
        self.orbs = self.geo.orbs
        self.basis = self.geo.basis
        self.pyq_basis = None

        try:
            self.orbs = self.geo.orbs
            choices = ['None','Density']
            for i in range(len(self.orbs)):
                choices.append(orb_str(i+1,self.orbs[i]))
        except:
            print "No orbitals found"
            self.Destroy()

        self.cval_label = wx.StaticText(self, -1, "Contour Value")
        self.cval_entry = wx.TextCtrl(self, -1, "0.3")
        self.grid_label = wx.StaticText(self, -1, "Grid")
        self.gridx_entry = wx.TextCtrl(self, -1, "16")
        self.gridy_entry = wx.TextCtrl(self, -1, "16")
        self.gridz_entry = wx.TextCtrl(self, -1, "16")
        self.orbital_label = wx.StaticText(self, -1, "Orbital")
        self.orb_choice = wx.ListBox(self, -1, choices=choices,
                                     style=wx.LB_SINGLE)
        self.action_label = wx.StaticText(self, -1, "Actions")
        self.ok_button = wx.Button(self, -1, "OK")
        self.close_button = wx.Button(self, -1, "Close")


        wx.EVT_BUTTON(self,self.ok_button.GetId(),self.view_orb)
        wx.EVT_BUTTON(self,self.close_button.GetId(),self.quit)

        self.SetTitle("Orbital Viewer")
        self.orb_choice.SetSelection(0)
        self.ok_button.SetDefault()

        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(4, 2, 0, 0)
        sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1.Add(self.cval_label, 0, 0, 0)
        grid_sizer_1.Add(self.cval_entry, 0, 0, 0)
        grid_sizer_1.Add(self.grid_label, 0, 0, 0)
        sizer_6.Add(self.gridx_entry, 0, 0, 0)
        sizer_6.Add(self.gridy_entry, 0, 0, 0)
        sizer_6.Add(self.gridz_entry, 0, 0, 0)
        grid_sizer_1.Add(sizer_6, 1, wx.EXPAND, 0)
        grid_sizer_1.Add(self.orbital_label, 0, 0, 0)
        grid_sizer_1.Add(self.orb_choice, 0, 0, 0)
        grid_sizer_1.Add(self.action_label, 0, 0, 0)
        sizer_5.Add(self.ok_button, 0, 0, 0)
        sizer_5.Add(self.close_button, 0, 0, 0)
        grid_sizer_1.Add(sizer_5, 1, wx.EXPAND, 0)
        sizer_1.Add(grid_sizer_1, 1, wx.EXPAND, 0)
        self.SetAutoLayout(1)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        sizer_1.SetSizeHints(self)
        self.Layout()
        return

    def quit(self,*args): self.Destroy()

    def view_orb(self,*args):
        index = self.orb_choice.GetSelection()
        self.cval = entry_float(self.cval_entry)
        self.nx = entry_int(self.gridx_entry)
        self.ny = entry_int(self.gridy_entry)
        self.nz = entry_int(self.gridz_entry)
        self.render_orbital(index)
        self.parent.render(1)
        return

    def render_orbital(self,index):
        self.geo.surface = []
        self.geo.nsurface = []
        if index == 0 : return
        if not self.pyq_basis:
            self.make_basis()
            self.bbox = bbox_atoms(self.geo.atoms)
            self.make_grid()
            self.nx0 = self.nx
            self.ny0 = self.ny
            self.nz0 = self.nz
            print "Orbital preprocessing done"
        if self.nx != self.nx0 or self.ny != self.ny0 or self.nz != self.nz0:
            print self.nx, self.nx0, self.ny, self.ny0,\
                  self.nz, self.nz0
            self.make_grid()
            self.nx0 = self.nx
            self.ny0 = self.ny
            self.nz0 = self.nz
            print "Orbital preprocessing done again"
            
        if not self.pyq_basis: return
        if index == 1:
            self.density_polygons()
        else:
            self.orbital_polygons(index)
        return

    def make_basis(self):
        try:
            from PyQuante.CGBF import CGBF
            from PyQuante.Ints import sym2powerlist
        except:
            print "PyQuante not available, using slower routines"
            print "Consider installing PyQuante to speed basis function evals"
            from Gaussian import CGBF, sym2powerlist

        self.pyq_basis = []
        for iat,atbasis in self.basis:
            origin = tuple(self.geo.atoms[iat-1].get_position())
            for type,prims in atbasis:
                for power in sym2powerlist[type]:
                    bf = CGBF(origin,power)
                    for expnt,coef in prims:
                        bf.add_primitive(expnt,coef)
                    bf.normalize()
                    self.pyq_basis.append(bf)
        return

    def density_polygons(self):
        self.geo.surface = []
        self.geo.nsurface = []
        densamps = zeros((self.nx,self.ny,self.nz),'d')
        for orb in self.orbs:
            sym,ene,spin,occ,coefs = orb
            if occ < 0.1: break # assume orbs are ordered by occ
            for ibf,coef in coefs:
                densamps += occ*pow(coef*self.basis_grid[ibf-1,:,:,:],2)

        for i in range(self.nx-1):
            for j in range(self.ny-1):
                for k in range(self.nz-1):
                    tris = contour(self.cval,
                                   self.xyz[i,j,k],self.xyz[i,j,k+1],
                                   self.xyz[i,j+1,k+1],self.xyz[i,j+1,k],
                                   self.xyz[i+1,j,k],self.xyz[i+1,j,k+1],
                                   self.xyz[i+1,j+1,k+1],self.xyz[i+1,j+1,k],
                                   densamps[i,j,k],densamps[i,j,k+1],
                                   densamps[i,j+1,k+1],densamps[i,j+1,k],
                                   densamps[i+1,j,k],densamps[i+1,j,k+1],
                                   densamps[i+1,j+1,k+1],densamps[i+1,j+1,k])
                    self.geo.surface.extend(tris)
        return
        

    def orbital_polygons(self,index):
        orb = self.orbs[index-2]
        coefs = orb[4]
        orbamps = zeros((self.nx,self.ny,self.nz),'d')
        for ibf,coef in coefs:
            orbamps += coef*self.basis_grid[ibf-1,:,:,:]

        self.geo.surface = []
        self.geo.nsurface = []
        for i in range(self.nx-1):
            for j in range(self.ny-1):
                for k in range(self.nz-1):
                    tris = contour(self.cval,
                                   self.xyz[i,j,k],self.xyz[i,j,k+1],
                                   self.xyz[i,j+1,k+1],self.xyz[i,j+1,k],
                                   self.xyz[i+1,j,k],self.xyz[i+1,j,k+1],
                                   self.xyz[i+1,j+1,k+1],self.xyz[i+1,j+1,k],
                                   orbamps[i,j,k],orbamps[i,j,k+1],
                                   orbamps[i,j+1,k+1],orbamps[i,j+1,k],
                                   orbamps[i+1,j,k],orbamps[i+1,j,k+1],
                                   orbamps[i+1,j+1,k+1],orbamps[i+1,j+1,k])
                    self.geo.surface.extend(tris)
                    tris = contour(-self.cval,
                                   self.xyz[i,j,k],self.xyz[i,j,k+1],
                                   self.xyz[i,j+1,k+1],self.xyz[i,j+1,k],
                                   self.xyz[i+1,j,k],self.xyz[i+1,j,k+1],
                                   self.xyz[i+1,j+1,k+1],self.xyz[i+1,j+1,k],
                                   orbamps[i,j,k],orbamps[i,j,k+1],
                                   orbamps[i,j+1,k+1],orbamps[i,j+1,k],
                                   orbamps[i+1,j,k],orbamps[i+1,j,k+1],
                                   orbamps[i+1,j+1,k+1],orbamps[i+1,j+1,k])
                    self.geo.nsurface.extend(permute(tris))
        return
            

    def make_grid(self):
        xmin,xmax,ymin,ymax,zmin,zmax = self.bbox
        dx = xmax-xmin
        dy = ymax-ymin
        dz = zmax-zmin
        nbf = len(self.pyq_basis)
        self.xyz = zeros((self.nx,self.ny,self.nz,3),'d')
        self.basis_grid = zeros((nbf,self.nx,self.ny,self.nz),'d')
        for i in range(self.nx):
            x = xmin + dx*i/(self.nx-1)
            for j in range(self.ny):
                y = ymin + dy*j/(self.ny-1)
                for k in range(self.nz):
                    z = zmin + dz*k/(self.nz-1)
                    self.xyz[i,j,k,0] = x
                    self.xyz[i,j,k,1] = y
                    self.xyz[i,j,k,2] = z
                    for ibf in range(nbf):
                        self.basis_grid[ibf,i,j,k] = self.pyq_basis[ibf].amp(x,y,z)
        return

def orb_str(i,orb): return "%4d %10.4f %10.4f" % (i,orb[1],orb[3])

def permute(tris):
    #In negative contours the triangles point the wrong way
    newtris = []
    for a,b,c in tris:
        newtris.append((a,c,b))
    return newtris
