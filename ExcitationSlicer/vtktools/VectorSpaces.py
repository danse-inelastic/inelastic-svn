""" Implementations of vectorspaces

These classes all implements vectorspaces. The following methods should always
be available:

'GetBasis' -- Returns the basis of the vectorspace or 'None'. 

'Vector(coordinates=[' *a1* , *a2* , *a3* '])' -- Returns a vector with
	the coordinates *a1* , *a2* , *a3* in the basis of the vectorspace. 

Other methods includes:

'SetBasis' -- Sets the basis of the vectorspace.

'CoordinatesFromCartesianCoordinates(coordinates=[' *xcoor* , *ycoor* , *zcoor* '])' 
	-- Gets the coordinates of the vector with  the coordinates 
   	*xcoor* , *ycoor* , *zcoor* in the basis of the vectorspace.

'CartesianCoordinatesFromCoordinates(coordinates=[' *a1* , *a2* , *a3* '])'
	 -- Gets the Cartesian coordinates of the vector with
	the coordinates *a1* , *a2* , *a3* in the basis of the vectorspace.

""" 

from Numeric import asarray,transpose,dot,arange,equal

CartesianSpaces={}

def TheCartesianSpace(dimension=3):
    if CartesianSpaces.has_key(dimension):
	return CartesianSpaces[dimension]
    else:
	CartesianSpaces[dimension]=_TheCartesianSpace_(dimension)
	return CartesianSpaces[dimension]

class _TheCartesianSpace_:
    """ Implements the general Cartesian space.
	
	This class represent a general Cartesian space.
	Each instance of different dimension is a singleton, ensuring that
        all ordinary n-dim vectors comes from the same vectorspace.
        A pointer to this object is generated by

        'TheCartesianSpace(' *dimension* ')'
    """

    def __init__(self,dimension):
	self.__dimension__=dimension

    def __repr__(self):
	    #ktrchange#
	s = str(self.__class__)
	
	import string
	n = string.rfind(s, '.')
	if n > 0:	#removes the rest the package path for prety printing
		s = s[n+1:]
	    
	return s+'(dimension='+str(self.__dimension__)+')'

    def GetBasis(self):
	"""  Returns the basis i.e. the unitmatrix of the right dimension. """
	return equal.outer(arange(self.__dimension__),arange(self.__dimension__))
        
    def CartesianCoordinatesFromCoordinates(self,coordinates):
	"""  Returns the Cartesian coordinates (i.e 'coordinates')"""
	return asarray(coordinates)

    def CoordinatesFromCartesianCoordinates(self,coor):
	"""  Returns the Cartesian coordinates (i.e 'coordinates')"""
	return asarray(coor)

    def MultiplyVector(self,vector,other):
	""" Multiplies a Vector with a scalar"""
	import copy
	from Numeric import asarray
	v=copy.copy(vector)
	if asarray(other).shape == ():
	    v.SetCartesianCoordinates(other*vector.GetCartesianCoordinates())
	    return v
	else:
	    raise ValueError, 'wrong multiplication of Vector'

    def RightMultiplyVector(self,vector,other):
	""" Right multiplies a Vector with a scalar"""
	return self.MultiplyVector(vector,other)

    def AddVectors(self,vector,other):
	""" Adds two Vectors"""
	if vector.GetSpace()==other.GetSpace():
	    import copy
	    v=copy.copy(vector)
	    v.SetCartesianCoordinates(vector.GetCartesianCoordinates()+other.GetCartesianCoordinates())
	    return v
	else:
	    raise ValueError, 'Addition of two vectors in different vector space not implemented'

    def SubtractVectors(self,vector,other):
	""" Subtract two Vectors"""
	if vector.GetSpace()==other.GetSpace():
	    import copy
	    v=copy.copy(vector)
	    v.SetCartesianCoordinates(vector.GetCartesianCoordinates()-other.GetCartesianCoordinates())
	    return v
	else:
	    raise ValueError, 'Subtraction of two vectors in different vector space not implemented'

    def InnerProduct(self,vector,other):
	"""Innerproduct for vectors"""
	if vector.GetSpace()==other.GetSpace():
	    return dot(vector.GetCartesianCoordinates(),other.GetCartesianCoordinates())
	else:
	    raise ValueError, 'Innerproduct of two vectors in different vector space not implemented'


    def PosVector(self,vector):
	""" Defines +vector"""
	import copy
	v=copy.copy(vector)
	return v

    def NegVector(self,vector):
	""" Defines -vector"""
	import copy
	v=copy.copy(vector)
	v.SetCartesianCoordinates(-vector.GetCartesianCoordinates())
	return v

class VectorSpaceWithBasis:
    """Class to represent a vector space with a basis.
    """

# Uses: LinearAlgebra
    
    def __init__(self,basis=[[1.,0,0],[0,1.,0],[0,0,1.]],units=None):
	self.SetBasis(basis)
	self.SetUnits(units)

    def __repr__(self):
	#ktrchange#
	s = str(self.__class__)
	
	import string
	n = string.rfind(s, '.')
	if n > 0:	#removes the rest the package path for prety printing
		s = s[n+1:]
	return s+'(basis='+str(self.Basis.tolist())+',units='+repr(self.Units)+')'
	#return str(self.__class__)+'(basis='+repr(self.Basis)+',units='+repr(self.Units)+')'

    def __mul__(self,other):
        import copy
        from Numeric import asarray,matrixmultiply
	a=copy.copy(self)
	if asarray(other).shape == ():
		a.SetBasis(self.GetBasis()*other)
	elif asarray(other).shape == self.GetBasis().shape:
		a.SetBasis(matrixmultiply(self.GetBasis(),other))
	else: 
        	raise ValueError, 'matrices are not aligned'
        return a

    def __rmul__(self,other):
        import copy
        from Numeric import asarray,matrixmultiply
        a=copy.copy(self)
	if asarray(other).shape == ():
		a.SetBasis(other*self.GetBasis())
	elif asarray(other).shape == self.GetBasis().shape:
		a.SetBasis(matrixmultiply(other,self.GetBasis()))
	else: 
        	raise ValueError, 'matrices are not aligned'
        return a

    def SetBasis(self,basis):
	from Numeric import asarray
	dim=len(basis)
	v=dim*[0]
	for i in range(dim):
	    try:
		v[i]=basis[i].GetCartesianCoordinates()
	    except:
		v[i]=basis[i]
	self.Basis=asarray(v)

    def GetBasis(self):
	return self.Basis

    def SetUnits(self,units):
	self.Units=units

    def GetUnits(self):
	return self.Units

    def CartesianCoordinatesFromCoordinates(self,coordinates):
	return dot(asarray(coordinates),self.GetBasis())

    def CoordinatesFromCartesianCoordinates(self,coordinates):
	from LinearAlgebra import solve_linear_equations
	return solve_linear_equations(transpose(self.GetBasis()),asarray(coordinates))
    
    def MultiplyVector(self,vector,other):
	""" Multiplies a Vector with a scalar"""
	import copy
	from Numeric import asarray
	v=copy.copy(vector)
	if asarray(other).shape == ():
	    v.SetCoordinates(other*vector.GetCoordinates())
	    return v
	else:
	    raise ValueError, 'wrong multiplication of Vector'

    def RightMultiplyVector(self,vector,other):
	""" Right multiplies a Vector with a scalar"""
	return self.MultiplyVector(vector,other)

    # self.GetName is used by GetTkManupulatorInterface
    def GetName(self):
	"""Return the attributes type name"""
	return 'VectorSpaceWithBasis'

    def AddVectors(self,vector,other):
	""" Adds two Vectors"""
	if vector.GetSpace()==other.GetSpace():
	    import copy
	    v=copy.copy(vector)
	    v.SetCoordinates(vector.GetCoordinates()+other.GetCoordinates())
	    return v
	else:
	    raise ValueError, 'Addition of two vectors in different vector space not implemented'

    def SubtractVectors(self,vector,other):
	""" Adds two Vectors"""
	if vector.GetSpace()==other.GetSpace():
	    import copy
	    v=copy.copy(vector)
	    v.SetCoordinates(vector.GetCoordinates()-other.GetCoordinates())
	    return v
	else:
	    raise ValueError, 'Subtraction of two vectors in different vector space not implemented'

    def InnerProduct(self,vector,other):
	"""Innerproduct for vectors"""
	if vector.GetSpace()==other.GetSpace():
	    from Numeric import matrixmultiply,transpose
	    # (v,o)=(v_coor^T*basis^T*basis*o_coor)
	    metric=matrixmultiply(self.GetBasis(),transpose(self.GetBasis()))
	    return dot(vector.GetCoordinates(),matrixmultiply(metric,other.GetCoordinates()))
	else:
	    raise ValueError, 'Innerproduct of two vectors in different vector space not implemented'


    def PosVector(self,vector):
	""" Defines +vector"""
	import copy
	v=copy.copy(vector)
	return v

    def NegVector(self,vector):
	""" Defines -vector"""
	import copy
	v=copy.copy(vector)
	v.SetCoordinates(-vector.GetCoordinates())
	return v

    def GetVolumeOfCell(self):
        """Returns the volume of the unit cell"""
        from LinearAlgebra import determinant
        # Using that V = |det(J)| where J is the Jacobian
        # For the basis set J=A, where r = A*x_i (x_i scaled coordinates)
        return abs(determinant(self.GetBasis()))
   
    def GetTkManipulator(self,parent=None,name=None):
	from Manipulators import TkVectorSpaceManipulator
	return TkVectorSpaceManipulator.TkVectorSpaceManipulator(self,parent,name)

class BravaisLattice(VectorSpaceWithBasis):
    """Class to represent a Bravais lattice with a basis for the lattice.
    """

# uses:	copy
#	Numeric
#       LinearAlgebra
#	Visualization.Avatars.vtkUnitCell
#       Manipulators.TkVectorSpaceManipulator

    def GetReciprocalBravaisLattice(self):
	from LinearAlgebra import inverse
	from Numeric import transpose,pi
	import copy
	reciprocal=copy.copy(self)
	# Using : rec=2pi*(unitcell^T)^-1
	recbasis=2*pi*inverse(transpose(self.GetBasis()))
	reciprocal.SetBasis(recbasis)
	return reciprocal

    def GetVTKAvatar(self,parent=None):
	"""Returns a VTK avatar for visualization"""
	from Visualization.Avatars.vtkUnitCell import vtkUnitCell
	return vtkUnitCell(self,parent=parent)
			





